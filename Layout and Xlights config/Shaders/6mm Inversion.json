{"working":false,"featured":false,"private":false,"stars":["5e7a7f587c113618206ddae3","5e9f3731658b34001590fe0d","5ed00fba9a2c7b001769388a","5fe5f08fdf59c70014cdc4e8","6067e767df59c70014cdc64c","60f5267ff4fe08001a0a6216","6109903e063978001a1c6ec2","63bdfee1d12ead001afe71e4","64bbf2515913c5001a3faeee","6595d3f3fe89e9001a206d9b","664c8791d15e30001b9f4a17","66e739b5813b3f001abda5e9","671aa9599e84f80019d261fa","678d2f6b2909a9001a029147","67f1bf8ea0bb96001afdec71","686346fd5d14de001ac87699"],"images":[],"categories":["5e7a80de7c113618206df13e","5e7a80de7c113618206df13b","5e7a80dd7c113618206df0ad","5e7a80de7c113618206df13c","5e7a80de7c113618206df13d","5e7a80de7c113618206df13f","5e7a80dd7c113618206df0d2"],"publicCategories":["Automatically Converted"],"privateCategories":["wallpapergroup","group","inversion","p6mm","symmetries","tiling"],"_id":"5e7a7fbe7c113618206de3ac","title":"p6mmInversion","rawFragmentSource":"/*{\n\t\"CREDIT\": \"by mojovideotech\",\n  \"CATEGORIES\" : [\n    \"group\",\n    \"tiling\",\n    \"inversion\",\n    \"p6mm\",\n    \"wallpapergroup\",\n    \"symmetries\",\n    \"Automatically Converted\"\n  ],\n  \"DESCRIPTION\" : \"Automatically converted from https:\\/\\/www.shadertoy.com\\/view\\/MtjGz3 by curena.  A planar pattern with all p6mm wallpaper group symmetries, mapped through a hyperbolic circle inversion + time dependent shift. Click and drag mouse to move inversion center.\",\n  \"INPUTS\" : [\n    {\n     \t\"NAME\": \"C\",\n\t\t\t\"TYPE\": \"point2D\",\n        \t\"DEFAULT\": [\n\t\t\t\t 2.0,\n\t\t\t\t-2.0\n\t  \t\t],\n    \t\t\"MAX\" : [\n        \t\t3.0,\n        \t\t3.0\n      \t\t],\n      \t\t\"MIN\" : [\n        \t\t-3.0,\n        \t\t-3.0\n      \t\t]\n    }\n  ]\n}\n*/\n\n\n// \"p6mm inversion\" by Carlos UreÃ±a - 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// *******************************************************************\n// global defs and params\n//\n\nconst float \n    sqr2     = 1.4142135623730950488016887242096980785696, // square root of 2\n    sqr3     = 1.7320508075688772935274463415058723669428, // square root of 3.0\n    sqr2_inv = 1.0/sqr2 ,\n    sqr3_inv = 1.0/sqr3 ,\n    l        = 0.5,       // length of triangle in NDC (mind --> 1.0)\n    l_inv    = 1.0/l ,\n    line_w   = 0.02 ;  // 0.015 \n\nconst vec2  \n    u        = 1.0*vec2( 1.0, 0.0  ) ,\n    v        = 0.5*vec2( 1.0, sqr3 ) ,\n    u_dual   = 1.0*vec2( 1.0, -sqr3_inv ) ,\n    v_dual   = 2.0*vec2( 0.0,  sqr3_inv ) ,\n    tri_cen  = vec2( 0.5, 0.5*sqr3_inv ) ; // triangle center\n\nvec2\n    center   = 0.5*RENDERSIZE.xy ;        // viewport center in DC \n\nfloat \n    mind   = min(RENDERSIZE.x,RENDERSIZE.y);\n\n// -------------------------------------------------------------------------------\n// mirror reflection of 'p' around and axis through 'v1' and 'v2'\n// (only for points to right of the line from v1 to v2)\n//\n\nvec2 mirror( vec2 p, vec2 v1, vec2 v2 )\n{\n \tvec2   s = v2-v1 ,\n           n = normalize(vec2( s.y, -s.x )) ;\n    float  d = dot(p-v1,n) ;\n    \n    return p-max(0.0,2.0*d)*n ;\n}\n// -------------------------------------------------------------------------------\n\nfloat dist( vec2 p, vec2 v1, vec2 v2 )\n{\n \tvec2   s = v2-v1 ,\n           n = normalize(vec2( s.y, -s.x )) ;\n    return dot(p-v1,n) ;\n}\n// -------------------------------------------------------------------------------\n\nvec2 p6mm_ToFundamental( vec2 p0 ) \n{\n    // p1 = fragment coords. in the grid reference frame\n    \n    vec2 p1 = vec2( dot(p0,u_dual), dot(p0,v_dual) );\n    \n    // p2 = fragment coords in the translated grid reference frame \n    \n    vec2 p2 = vec2( fract(p1.x), fract(p1.y) ) ;\n    \n    // p3 = barycentric coords in the translated triangle\n    // (mirror, using line x+y-1=0 as axis, when point is right and above axis)\n    \n    vec2 p3 = mirror( p2, vec2(1.0,0.0), vec2(0.0,1.0) );\n    \n    // p4 = p3, but expressed back in cartesian coordinates\n    \n    vec2 p4 = p3.x*u + p3.y*v ;\n    \n    // p7 = mirror around the three lines through the barycenter, perp. to edges.\n    \n    vec2 p5 = mirror( p4, vec2(0.5,0.0), tri_cen );\n    vec2 p6 = mirror( p5, vec2(1.0,0.0), tri_cen );\n    vec2 p7 = mirror( p6, tri_cen, vec2(0.0,0.0) );\n  \n    return p7 ;\n}\n\n// --------------------------------------------------------------------\n\nfloat DistanceFunc( float d )\n{\n    \n   return 1.0-smoothstep( line_w*0.85, line_w*1.15, d );   \n}\n\n// -------------------------------------------------------------------------------\n\nvec4 p6mm_SimmetryLines( vec2 p_ndc )\n{\n\n    vec2 pf = p6mm_ToFundamental( p_ndc );\n    \n    float d1 = abs(pf.y),\n          d2 = abs(pf.x-0.5),\n          d3 = abs( dist( pf, tri_cen, vec2(0.0,0.0) ) );\n     \n    vec4 res = vec4( 0.0, 0.0, 0.0, 1.0 ) ;\n        \n    res.r = DistanceFunc(d2);\n    res.g = DistanceFunc(d1);\n    res.b = DistanceFunc(d3);\n    \n    return res ;    \n}\n// -------------------------------------------------------------------------------\n\nvec2 DCToNDC( vec2 p_dc )\n{\n    return l_inv*(p_dc - center)/mind ;\n}\n// --------------------------------------------------------------------\n\nvec2 Inversion( vec2 p, vec2 cen )\n{\n   const float speedFactor = 0.5 ;\n   float secs = TIME*speedFactor ;\n   vec2  vr   = p  -cen ;\n   float r    = length( vr );\n   \n    return cen + normalize(vr)/(r*0.1) \n              + secs/4.0*vec2(1.0,0.5)  \n              + 1.0*l*vec2( sin(secs/37.0), cos(secs/29.0) ) ;\n}\n\n// -------------------------------------------------------------------------------\n\nvoid main()\n{\n    const int n = 6 ;\n    const float n_inv = 1.0/float(n) ;\n    \n    vec4 res = vec4( 0.0, 0.0, 0.0, 1.0 );\n    \n    vec2 mou = DCToNDC( 0.5*RENDERSIZE.xy );\n        mou  += C.xy  ;\n    \n    \n    for (int ix = 0 ; ix < n ; ix += 1 )\n    for (int iy = 0 ; iy < n ; iy += 1 )\n    {\n       float px = -0.5 + (0.5+float(ix))*n_inv,   \n             py = -0.5 + (0.5+float(iy))*n_inv ;\n        \n       vec2 pNDC = DCToNDC( gl_FragCoord.xy + vec2( px, py ) );\n            \n       vec2 pinv = Inversion( pNDC, mou ) ;\n        \n       res += p6mm_SimmetryLines( pinv );\n    }\n    \n    gl_FragColor = n_inv*n_inv*res ;   \n}\n// -------------------------------------------------------------------------------","rawVertexSource":"void main() {\n\tvv_vertShaderInit();\n}","thumbnailCloudinaryId":"x5qgorq3cdadcpr4up8l","description":"Automatically converted from https://www.shadertoy.com/view/MtjGz3 by curena.  A planar pattern with all p6mm wallpaper group symmetries, mapped through a hyperbolic circle inversion + time dependent shift. Click and drag mouse to move inversion center.","shaderType":"generator","oldId":"1246","createdAt":"2016-07-21T22:44:36.754Z","user":{"_id":"5e7a7f587c113618206dda0d","username":"mojovideotech","name":"Mojo Video Tech","id":"5e7a7f587c113618206dda0d"},"username":"mojovideotech","updatedAt":"2025-07-01T02:40:53.470Z","__v":1,"id":"5e7a7fbe7c113618206de3ac"}