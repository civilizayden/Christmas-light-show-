{"working":false,"featured":false,"private":false,"stars":["607195c8df59c70014cdc659","60c1b13cdf59c70014cdc6d6","631c6ba4d12ead001af46c0d","6331d80ed12ead001af59b4b","642c873f24251a001ac99526","6238d8aafa1461001483fd4b","6595d3f3fe89e9001a206d9b","64ab22d1073c7a001a87c0c3","66ebafbf522bf8001ae857ae"],"images":[],"categories":["5e7a82fdda37220013c9c328"],"publicCategories":[],"privateCategories":["generator"],"_id":"6055d69bd4849b0013135d65","title":"Fire Within","rawFragmentSource":"/*\n\t{\n\t\"DESCRIPTION\": \"Fire Within\",\n\t\"CATEGORIES\": \n\t\t[\n\t\t\"generator\"\n\t\t],\n\t\"ISFVSN\": \"2\",\n\t\"CREDIT\": \"ISF Import by: Old Salt\",\n\t\"VSN\": \"1.0\",\n\t\"INPUTS\":\n\t\t[\n\t\t\t{\n\t\t\t\"NAME\": \"uC1\",\n\t\t\t\"TYPE\": \"color\",\n\t\t\t\"DEFAULT\":[0.0,1.0,0.0,1.0]\n\t\t\t},\n\t\t\t{\n\t\t\t\"NAME\": \"uC2\",\n\t\t\t\"TYPE\": \"color\",\n\t\t\t\"DEFAULT\":[0.0,0.0,1.0,1.0]\n\t\t\t},\n\t\t\t{\n\t\t\t\"NAME\": \"uC3\",\n\t\t\t\"TYPE\": \"color\",\n\t\t\t\"DEFAULT\":[1.0,0.0,0.0,1.0]\n\t\t\t},\n\t\t\t{\n\t\t\t\"LABEL\": \"View Point: \",\n\t\t\t\"NAME\": \"uView\",\n\t\t\t\"TYPE\": \"point2D\",\n\t\t\t\"MAX\": [1.0,1.0],\n\t\t\t\"MIN\": [-1.0,-1.0],\n\t\t\t\"DEFAULT\": [0.0,0.0]\n\t\t\t},\n\t\t\t{\n\t\t\t\"LABEL\": \"Zoom: \",\n\t\t\t\"NAME\": \"uZoom\",\n\t\t\t\"TYPE\": \"float\",\n\t\t\t\"MAX\": 4.0,\n\t\t\t\"MIN\": 0.01,\n\t\t\t\"DEFAULT\": 1.0\n\t\t\t},\n\t\t\t{\n\t\t\t\"LABEL\": \"Rotation(or R Speed):\",\n\t\t\t\"NAME\": \"uRotate\",\n\t\t\t\"TYPE\": \"float\",\n\t\t\t\"MAX\": 180.0,\n\t\t\t\"MIN\": -180.0,\n\t\t\t\"DEFAULT\": 0.0\n\t\t\t},\n\t\t\t{\n\t\t\t\"LABEL\": \"Continuous Rotation? \",\n\t\t\t\"NAME\": \"uContRot\",\n\t\t\t\"TYPE\": \"bool\",\n\t\t\t\"DEFAULT\": 1\n\t\t\t},\n\t\t\t{\n\t\t\t\"LABEL\": \"Color Mode: \",\n\t\t\t\"LABELS\":\n\t\t\t\t[\n\t\t\t\t\"Shader Defaults \",\n\t\t\t\t\"Alternate Color Palette (3 used) \"\n\t\t\t\t],\n\t\t\t\"NAME\": \"uColMode\",\n\t\t\t\"TYPE\": \"long\",\n\t\t\t\"VALUES\": [0,1],\n\t\t\t\"DEFAULT\": 0\n\t\t\t},\n\t\t\t{\n\t\t\t\"LABEL\": \"Intensity: \",\n\t\t\t\"NAME\": \"uIntensity\",\n\t\t\t\"TYPE\": \"float\",\n\t\t\t\"MAX\": 4.0,\n\t\t\t\"MIN\": 0,\n\t\t\t\"DEFAULT\": 1.0\n\t\t\t}\n\t\t]\n\t}\n*/\n// Import from: https://www.shadertoy.com/view/tttfzl\n\n#define PI 3.141592653589\n#define rotate2D(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n// Imported Shader defined uniforms and functions:\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nfloat Hash21(vec2 p) \n\t{\n\tp = fract(p*vec2(123.34,233.53));\n\tp += dot(p, p+23.234);\n\treturn fract(p.x*p.y);\n\t}\n\nfloat sdBox(vec3 p, vec3 s)\n\t{\n\tp = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n\t}\n\nfloat sdGyroid(vec3 p,float scale, float thickness, float bias)\n\t{\n\tp*=scale;\n\t// can also play with the p and p.zxy by adding some numbers \n\t// scale needs to add the largest multiplers in either p or p.zxy \n\t// return abs(dot(sin(p*2.),cos(p.zxy*1.23))-bias)/(scale*2.)-thickness;\n\treturn abs(dot(sin(p),cos(p.zxy))-bias)/scale-thickness;\n\t}\n    \nvec3 Transform(vec3  p)\n\t{\n\tp.xy*=rotate2D(p.z*.15);\n\tp.z -=TIME*.1;\n\tp.y -= .3;\n\treturn p;\n\t}\n\nfloat GetDist(vec3 p)\n\t{\n\tp=Transform(p);\n\tfloat box = sdBox(p, vec3(1));\n\n\t// wanting something organic? the scales for two should not be multiplicable by each other (ex.: can't be 4 and 8)\n\tfloat g1 = sdGyroid(p, 5.23, .03, 1.4);\n\tfloat g2 = sdGyroid(p, 10.76, .03, .3);\n\tfloat g3 = sdGyroid(p, 20.76, .03, .3);\n\tfloat g4 = sdGyroid(p, 35.76, .03, .3);\n\tfloat g5 = sdGyroid(p, 60.76, .03, .3);\n\tfloat g6 = sdGyroid(p, 110.76, .03, .3);\n\tfloat g7 = sdGyroid(p, 210.76, .03, .3);\n\n\t//float g = max(g1,g2);//union \n\t//float g = max(g1,-g2);//subtraction \n\t//bump mapper\n\tg1 -= g2*.4;\n\tg1 -= g3*.3;\n\tg1 += g4*.2;\n\tg1 += g5*.2;\n\tg1 += g6*.3;\n\tg1 += g7*.5;\n\n\t//float d=max(box,g1*.8);// intersect the box \n\tfloat d = g1*.8;\n\treturn d;\n\t}\n\nfloat RayMarch(vec3 ro, vec3 rd)\n\t{\n\tfloat dO=0.;\n\tfor(int i=0; i<MAX_STEPS; i++)\n\t\t{\n\t\tvec3 p = ro + rd*dO;\n\t\tfloat dS = GetDist(p);\n\t\tdO += dS;\n\t\tif(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n\t\t}\n\t\treturn dO;\n\t}\n\nvec3 GetNormal(vec3 p)\n\t{\n\tfloat d = GetDist(p);\n\n\t// the e.x determines the smoothness\n\tvec2 e = vec2(.025, 0);\n\tvec3 n = d - vec3(\n\t\tGetDist(p-e.xyy),\n\t\tGetDist(p-e.yxy),\n\t\tGetDist(p-e.yyx));\n\treturn normalize(n);\n\t}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z)\n\t{\n\tvec3 f = normalize(l-p),\n\t\tr = normalize(cross(vec3(0,1,0), f)),\n\t\tu = cross(f,r),\n\t\tc = f*z,\n\t\ti = c + uv.x*r + uv.y*u,\n\t\td = normalize(i);\n\treturn d;\n\t}\n\nvec3 Background(vec3 rd)\n\t{\n\tfloat t = TIME*.2;\n\tvec3 col = vec3(0);\n\tvec3 fireCol = vec3(1,.45,.1);\n\tfloat y = rd.y*.5+.5;\n\tcol+=(1.-y)*fireCol;\n\n\t//make flames\n\t//smoothstep to make the top dark and bottom bright \n\tfloat a = atan(rd.x,rd.z);\n\tfloat flames = sin(a*10.+t)*sin(a*7.-t)*sin(a*3.);\n\tflames *=smoothstep(0.8,0.6,y);\n\tcol*=flames;\n\tcol = max(col,0.);\n\tcol+=smoothstep(.3,.0,y);\n\treturn col;\n\t}\n\n\nvoid main()\n\t{\n\tvec2 uv = gl_FragCoord.xy/RENDERSIZE - 0.5; // normalize coordinates\n\tuv.x *= RENDERSIZE.x/RENDERSIZE.y;          // correct aspect ratio\n\tuv *= (1.0/uZoom);              // offset and zoom functions\n\tuv = uContRot ? uv*rotate2D(TIME*uRotate/36.0) : uv*rotate2D(uRotate*PI/180.0); // rotation\n\n/**** Start of Core Imported Shader Code *****/\n\tvec2 m = (uView+1.0)/2.0;  //\tiMouse.xy/iResolution.xy;\n\tfloat t = TIME*0.2;\n\tvec3 col = vec3(0);\n\tvec3 fireCol = vec3(1,.45,.1);\n\n\t//distort effect \n\tuv +=sin(uv*20.+t)*.01;\n\tvec3 ro = vec3(0, 0, -1);\n\tro.yz *= rotate2D(-m.y*3.14+1.);\n\tro.xz *= rotate2D(-m.x*6.2831);\n\n\tvec3 lookat = vec3(0,0,0);\n\t//zoom factor 1\n\tvec3 rd = GetRayDir(uv, ro, lookat, .8);\n\tfloat d = RayMarch(ro, rd);\n\tif(d<MAX_DIST)\n\t\t{\n\t\tvec3 p = ro + rd * d;\n\t\tvec3 n = GetNormal(p);\n\t\tfloat height = p.y;\n\t\tp = Transform (p);\n\t\tfloat dif = n.y*.5+.5;\n\t\tcol+=dif*dif*dif;// 0 <> 1 \n\n\t\t//ambient occulusion - cheaper \n\t\tfloat g2 = sdGyroid(p, 10.76, .03, .3);\n\t\tcol*=smoothstep(-.1,.05,g2);//blackening \n\t\tfloat crackWidth = -.02+smoothstep(0., -.5, n.y)*.04;\n\t\tfloat cracks = smoothstep(crackWidth,-.025,g2);\n\t\tfloat g3 = sdGyroid(p+t*.1, 5.76, .03, .0);\n\t\tfloat g4 = sdGyroid(p-t*.05, 4.76, .03, .0);\n\t\tcracks *=g3*g4*20.+.1*smoothstep(.2,.0,n.y);\n\t\tcol+=cracks*fireCol*3.;\n\t\tfloat g5 = sdGyroid(p-vec3(0,t,0),1.85,.02,1.3);\n\t\tcol+=g5*fireCol;\n\t\tcol +=smoothstep(0.,-2.,height)*fireCol;\n\t\t}\n\tcol = mix(col, Background(rd), smoothstep(0., 7., d));\n\t//col = Background(rd);\n\tcol*=1.-dot(uv,uv);\n\n/****  End of Core Imported Shader Code  *****/\n\tvec4 cShad = vec4(col,1.0);  \n\tvec3 cOut = cShad.rgb;\n\tif (uColMode == 1)\n\t\t{\n\t\tcOut = uC1.rgb * cShad.r;\n\t\tcOut += uC2.rgb * cShad.g;\n\t\tcOut += uC3.rgb * cShad.b;\n\t\t}\n\tcOut = cOut * uIntensity;\n\tcOut = clamp(cOut, vec3(0.0), vec3(1.0));\n\tgl_FragColor = vec4(cOut.rgb,cShad.a);\n\t}\n\t","rawVertexSource":"\nvoid main() {\n  isf_vertShaderInit();\n}\n","description":"Fire Within","scale":1,"user":{"_id":"604b8fc8df59c70014cdc5fc","username":"Old_Salt","name":"Old Salt","id":"604b8fc8df59c70014cdc5fc"},"username":"Old_Salt","createdAt":"2021-03-20T11:03:55.856Z","updatedAt":"2025-07-08T08:54:16.880Z","__v":7,"thumbnailCloudinaryId":"kzuxahwtyz01r67lawlr","id":"6055d69bd4849b0013135d65"}